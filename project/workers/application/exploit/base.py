from typing import Type


class BaseExploit:
    name: str = ''

    def handle(self, **kwargs):
        try:
            body = self.extract(**kwargs)
            result = self.run(**body)
        except Exception as ex:
            result = {"messages": [
                {
                    "command": None,
                    "message": str(ex)
                }
            ]}

        return {
            "type": "exploit",
            "name": self.name,
            "result": result
        }

    def extract(self, **kwargs):
        return kwargs

    def run(self, **kwargs):
        return kwargs


class Singleton(object):
    _instances = {}

    def __new__(cls, *args, **kwargs):
        if cls.__name__ not in cls._instances:
            cls._instances[cls.__name__] = super().__new__(cls, *args, **kwargs)
        return cls._instances[cls.__name__]


class Manager(Singleton):

    _exploits = {}

    def __init__(
            self,
            exploit: BaseExploit = BaseExploit
    ):
        for subclass in exploit.__subclasses__():
            self.register_exploit(subclass)
            self.__init__(subclass)

    def register_exploit(self, exploit: Type[BaseExploit]):
        if exploit.name.lower() in self._exploits:
            raise Exception(f"Duplicate name: name={exploit.name} already use in {exploit.__name__}")

        if not exploit.name:
            raise Exception("Empty values in parent or name")

        self._exploits[exploit.name.lower()] = exploit

    def check_exists(self, name: str):
        return bool(self._exploits.get(name.lower()))

    def handle(self, name: str, **kwargs):
        if self.check_exists(name.lower()):
            exploit = self._exploits.get(name.lower())
            return exploit().handle(**kwargs)

        raise Exception(f"Not found exploit with {name=}")